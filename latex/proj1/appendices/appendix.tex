\subsection{Extended Euclidean Algorithm}
\label{sec:ext-euclid-alg}
\begin{minted}{rust}
  use rug::{Complete, Integer};

  pub fn extended_euclidean_ordered(a: &Integer, b: &Integer) -> (Integer, Integer, Integer) {
      // There have been no attempt to optimize this function using cloning and references
      // efficiently.
      let mut a1: Integer = a.clone();
      let mut b1: Integer = b.clone();

      if b.is_zero() {
          return (a1, Integer::ONE.clone(), Integer::ZERO.clone())
      };

      let mut x2: Integer = Integer::ONE.clone();
      let mut x1: Integer = Integer::ZERO.clone();
      let mut y2: Integer = Integer::ZERO.clone();
      let mut y1: Integer = Integer::ONE.clone();


      while b1 > Integer::ZERO {
          // q = a1/b1;
          let (q, _) = (a1.div_rem_floor_ref(&b1)).complete();
          let r = a1 - &q*&b1;
          let x = x2 - &q*&x1;
          let y = y2 - &q*&y1;
          a1 = b1;
          b1 = r;
          x2 = x1;
          x1 = x;
          y2 = y1;
          y1 = y;
      };

      (a1, x2, y2)
  }
\end{minted}


\subsection{Exponentiation}
\label{sec:exp}

\begin{minted}{rust}
  pub fn pow_rug(a: &Integer, b: &Integer, n: &Integer) -> Integer {
      let mut product: Integer = Integer::ONE.clone();
      let mut base = a.clone() % n;
      let mut exponent = b.clone();

      while exponent != 0 {
          if exponent.get_bit(0) {
              product = (product * &base).modulo(n);
          }
          base = base.square().modulo(n);
          exponent = exponent >> 1;
      }
      product
  }
\end{minted}
